import cv2
import time
from queue import PriorityQueue
import matplotlib.pyplot as plt
import numpy as np
import pygame 
import copy

#Defining the four walls. The point should lie within the boundary
def Main_Wall(x, y):
    if (x<=0) or (x>=600) or (y<=0) or (y>=250):
        return True
    else:
        return False

#Creating and defining obstacle spaces
def Rectangle_Top(x, y):
    if (x >=100) and (x <=150) and (y>=150) and (y<=250):
        return True
    else:
        return False

def Rectangle_Bottom(x, y):
    if (x >=100) and (x <=150) and (y>=0) and (y<=100):
        return True
    else:
        return False
    
def Triangle(x, y):
    if (x>=460) and (((y-25)-(2*(x-460)))>=0) and (((y-125)-((-2)*(x-510)))>=0):
        return True
    else:
        return False

def Hexagon(x, y):
    # if (x>=85.05) and (x<=214.95) and (((y-50)-(((87.5-50)/(364.95-300))*(x-300)))>=0) and (((y-50)-(((87.5-50)/(235.05-300))*(x-300)))>=0) and (((y-162.5)-(((162.5-200)/(364.95-300))*(x-364.95)))<=0) and (((y-162.5)-(((162.5-200)/(235.05-300))*(x-235.05)))<=0):
    if (x>=235.05) and (x<=364.95) and (((y-50)-(0.577*(x-300)))>=0) and (((y-50)-((-0.577)*(x-300)))>=0) and (((y-162.5)-((-0.577)*(x-364.95)))<=0) and (((y-162.5)-((0.577)*(x-235.05)))<=0):
        return True
    else:
        return False
    
def Obstacle_space(x, y):
    if (Main_Wall(x, y) or Rectangle_Top(x, y) or Rectangle_Bottom(x, y) or Triangle(x, y) or Hexagon(x, y)) == True:
        return True
    else:
        return False

 # Defining the movements: up. left. right, down, up left, up right, down left and down right   
def ActionMoveUp(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveLeft(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveRight(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveUp_left(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveUp_right(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown_left(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown_right(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

    
# start_point_x = input("Enter the x-coordinate of the start point \n")
# start_point_y = input("Enter the y-coordinate of the start point \n")
# while Obstacle_space(int(start_point_x), int(start_point_y)):
#     print("These coordinates lie inside the obstacle space. Please enter new values\n")
#     start_point_x = input("Enter the x-coordinate of the start point \n")
#     start_point_y = input("Enter the y-coordinate of the start point \n")

# goal_point_x = input("Enter the x-coordinate of the goal point \n")
# goal_point_y = input("Enter the y-coordinate of the goal point \n")
# while Obstacle_space(int(start_point_x), int(start_point_y)):
#     print("These coordinates lie inside the obstacle space. Please enter new values\n")
#     goal_point_x = input("Enter the x-coordinate of the goal point \n")
#     goal_point_y = input("Enter the y-coordinate of the goal point \n")

def dijkstra_node_info(cost_to_come, Parent_Node_Index_i, current_node):
    dijkstra_node = [cost_to_come, Parent_Node_Index_i, current_node]
    return dijkstra_node

# start_point= [int(start_point_x), int(start_point_y)]
# goal_point= [int(goal_point_x), int(goal_point_y)]
start_point= (50, 50)
goal_point= (580, 240)
C2C = 0
parent_node = None
start_node = dijkstra_node_info(C2C, parent_node, start_point)
open_list = PriorityQueue()
visited_closed_list = {} #to store visited nodes
open_list.put(start_node)    
visited_x_coord = []
visited_y_coord =[]

while True:
    current_node = open_list.get()
    if current_node[2] in visited_closed_list:
        continue
    visited_x_coord.append(current_node[2][0])
    visited_y_coord.append(current_node[2][1])
    visited_closed_list[current_node[2]] = (current_node[1])
    if current_node[2] == goal_point:
        print("The goal has been reached \n")
        print("Total cost:", current_node[0])
        print("X and Y coordinate:", current_node[2][0], current_node[2][1])
        break
    else:
        current_node = ActionMoveUp(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                # current_node = dijkstra_node_info(C2C, parent_node, node)
                open_list.put(current_node)

        current_node = ActionMoveDown(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveLeft(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveRight(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveUp_left(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveUp_right(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveDown_left(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveDown_right(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)

#Backtracking function
generated_path = []
temp = goal_point
while temp != goal_point:
    generated_path.append(temp)
    generated_path = visited_closed_list[current_node[2]]   
generated_path.append(start_point)
generated_path.reverse()


x = [] #to store respective values from generated path
y = []
for i in range(len(generated_path)):
    x.append(generated_path[i][0])
    y.append(generated_path[i][1])

plt.ylabel('Y-axis')
plt.xlabel('X-axis')
plt.axis([0 , 600 , 0 ,250])

temp_x = 0
temp_y = 0
plt.title("Plotting Visited list")
for i in range(len(a)) :
    if temp_x == goal_point[0] and temp_y == goal_point[1] :
        break
    if len(visited_x_coord)>100:
        plt.scatter(visited_x_coord[0:100] , visited_y_coord[0:100] , c='green' , s=1)
        plt.pause(0.0005)
        del visited_x_coord[:100]
        del visited_y_coord[:100]
    else :
        for j in range(len(visited_y_coord)):
            plt.scatter(visited_x_coord[j] , visited_y_coord[j] , c='green' , s=1)
            plt.pause(0.0005)
            temp_x = visited_x_coord[j]
            temp_y = visited_y_coord[j]
            if visited_x_coord[j] == goal_point[0] and visited_y_coord[j] == goal_point[1] :
                break



plt.title("Shortest path generated")
for i in range(len(x)):
    plt.scatter(x[i] , y[i] , c='red' , s=2, marker='D')
    plt.pause(0.00005)

plt.show

