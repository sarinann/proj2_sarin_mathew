import cv2
import time
from queue import PriorityQueue
import matplotlib.pyplot as plt
import numpy as np
import pygame 
import copy

#Defining the four walls. The point should lie within the boundary
def Main_Wall(x, y):
    if (x<=0) or (x>=600) or (y<=0) or (y>=250):
        return True
    else:
        return False

#Creating and defining obstacle spaces
def Rectangle_Top(x, y):
    if (x >=100) and (x <=150) and (y>=150) and (y<=250):
        return True
    else:
        return False

def Rectangle_Bottom(x, y):
    if (x >=100) and (x <=150) and (y>=0) and (y<=100):
        return True
    else:
        return False
    
def Triangle(x, y):
    if (x>=460) and (((y-25)-(2*(x-460)))>=0) and (((y-125)-((-2)*(x-510)))>=0):
        return True
    else:
        return False

def Hexagon(x, y):
    # if (x>=85.05) and (x<=214.95) and (((y-50)-(((87.5-50)/(364.95-300))*(x-300)))>=0) and (((y-50)-(((87.5-50)/(235.05-300))*(x-300)))>=0) and (((y-162.5)-(((162.5-200)/(364.95-300))*(x-364.95)))<=0) and (((y-162.5)-(((162.5-200)/(235.05-300))*(x-235.05)))<=0):
    if (x>=235.05) and (x<=364.95) and (((y-50)-(0.577*(x-300)))>=0) and (((y-50)-((-0.577)*(x-300)))>=0) and (((y-162.5)-((-0.577)*(x-364.95)))<=0) and (((y-162.5)-((0.577)*(x-235.05)))<=0):
        return True
    else:
        return False
    
def Obstacle_space(x, y):
    if (Main_Wall(x, y) or Rectangle_Top(x, y) or Rectangle_Bottom(x, y) or Triangle(x, y) or Hexagon(x, y)) == True:
        return True
    else:
        return False

 # Defining the movements: up. left. right, down, up left, up right, down left and down right   
def ActionMoveUp(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveLeft(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveRight(node):
    node[0]+=1
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveUp_left(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveUp_right(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]+1
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown_left(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    modified_node[2][0]=modified_node[2][0]-1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

def ActionMoveDown_right(node):
    node[0]+=1.4
    parent_node = node[2]
    modified_node = copy.deepcopy(node)    
    modified_node[2][1]=modified_node[2][1]-1
    modified_node[2][0]=modified_node[2][0]+1
    passed_node = dijkstra_node_info(node[0], parent_node, modified_node)
    return True, passed_node

    
# start_point_x = input("Enter the x-coordinate of the start point \n")
# start_point_y = input("Enter the y-coordinate of the start point \n")
# while Obstacle_space(int(start_point_x), int(start_point_y)):
#     print("These coordinates lie inside the obstacle space. Please enter new values\n")
#     start_point_x = input("Enter the x-coordinate of the start point \n")
#     start_point_y = input("Enter the y-coordinate of the start point \n")

# goal_point_x = input("Enter the x-coordinate of the goal point \n")
# goal_point_y = input("Enter the y-coordinate of the goal point \n")
# while Obstacle_space(int(start_point_x), int(start_point_y)):
#     print("These coordinates lie inside the obstacle space. Please enter new values\n")
#     goal_point_x = input("Enter the x-coordinate of the goal point \n")
#     goal_point_y = input("Enter the y-coordinate of the goal point \n")

def dijkstra_node_info(cost_to_come, Parent_Node_Index_i, current_node):
    dijkstra_node = [cost_to_come, Parent_Node_Index_i, current_node]
    return dijkstra_node

# start_point= [int(start_point_x), int(start_point_y)]
# goal_point= [int(goal_point_x), int(goal_point_y)]
start_point= (50, 50)
goal_point= (580, 240)
C2C = 0
parent_node = None
start_node = dijkstra_node_info(C2C, parent_node, start_point)
open_list = PriorityQueue()
visited_closed_list = {} #to store visited nodes
open_list.put(start_node)    
visited_x_coord = []
visited_y_coord =[]

while True:
    current_node = open_list.get()
    if current_node[2] in visited_closed_list:
        continue
    visited_x_coord.append(current_node[2][0])
    visited_y_coord.append(current_node[2][1])
    visited_closed_list[current_node[2]] = (current_node[1])
    if current_node[2] == goal_point:
        print("The goal has been reached \n")
        print("Total cost:", current_node[0])
        print("X and Y coordinate:", current_node[2][0], current_node[2][1])
        break
    else:
        current_node = ActionMoveUp(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                # current_node = dijkstra_node_info(C2C, parent_node, node)
                open_list.put(current_node)

        current_node = ActionMoveDown(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveLeft(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveRight(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveUp_left(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveUp_right(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveDown_left(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)
        
        current_node = ActionMoveDown_right(current_node)
        if Obstacle_space(current_node[2][0], current_node[2][0]) == False:
            if current_node[2] not in visited_closed_list:
                open_list.put(current_node)

def dijkstra_algo(start, goal):
    #Initializing the start node
    start_node = dijkstra_node_create(0, None, start)
    #Intializing the queue
    open_queue = PriorityQueue()
    open_queue.put(start_node)

    #initialize the dictionary to hold the path cost from start to every node
    cost_from_start = {start: 0}

    #initialize the dictionary to hold the parent node for each visited node
    visited_closed_dict = {start: None}

    while not open_queue.empty():
        #Remove and return the lowest-cost node
        current_node = open_queue.get()
        
        #Check if we have reached the goal coordinates
        if current_node[2] == goal:
            #return the path by backtracking from goal to start
            generated_path = []
            while current_node is not None:
                generated_path.append(current_node[2])
                current_node = visited_closed_dict[current_node[2]]
            #Reverse the path and return
            return generated_path[::-1]
        
        #If the goal is not reached, expand the current node
        actions = [ActionMoveUp, ActionMoveDown, ActionMoveLeft, ActionMoveRight, ActionMoveUp_left, ActionMoveUp_right, ActionMoveDown_left, ActionMoveDown_right]
        for action in actions:
            #Get the modified node and its cost to move from current node
            new_node = action(current_node)
            cost = new_node[0]
            
            #If the node is not in the cost dictionary, add it with infinite cost
            if new_node[2] not in cost_from_start:
                cost_from_start[new_node[2]] = float('inf')
            
            #Check if the cost to reach the new node is less than the recorded cost, update the cost and visited node
            if cost < cost_from_start[new_node[2]]:
                cost_from_start[new_node[2]] = cost
                visited_closed_dict[new_node[2]] = current_node
                
                #Add the new node to the queue
                open_queue.put(new_node)

    #If the goal is not reached and the queue is empty, there is no path to the goal
    return None

